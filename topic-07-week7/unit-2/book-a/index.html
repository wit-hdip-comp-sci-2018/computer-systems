<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.css"
        type="text/css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/railscasts.min.css"
        rel="stylesheet"/>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/jquery.address/1.6/jquery.address.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <style>
    

body {
  font-family: "Open Sans", "Helvetica", "Helvetica Neue",  "Arial", sans-serif;
  font-size:90%;
  color: black;
}

p {
  margin: 0.5em;
}

pre code {
  font-family: "Monaco";
  font-size: 100%;
}

img {
  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
  margin:10px;
}

h1, h2, h3 {
  border-bottom:thin solid black;
  margin-bottom: 0.5em;
  margin-top: 1em;
}

h1 {
  font-style:italic;
  font-size:130%;
}

h2 {
  font-size:110%;
}

h3 {
  font-size:100%;
}



  </style>
</head>

<body>



<div class="ui fixed top pointing inverted stackable menu labmenu">
  <header class="header item">
    <i id="toc" class="sitemap icon"></i>
    
      <a href="../../index.html">  Transport Layer  </a>
    
  </header>
  <div class="right tab-menu menu">
    
      <a class="item" data-tab="TCP-Sockets">
        TCP-Sockets
      </a>
    
      <a class="item" data-tab="01">
        01
      </a>
    
      <a class="item" data-tab="02">
        02
      </a>
    
      <a class="item" data-tab="03">
        03
      </a>
    
  </div>
</div>

<div class="ui pushable">
  <div class="ui inverted labeled icon left inline vertical sidebar menu">
    <br><br>
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-00-open-day/book-1/index.html">Preparatory Lab </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-00-open-day/book-2/index.html">Shell Scripting </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-00-open-day/book-3/index.html">Vagrant and Sense HAT </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-01-week1/unit-1/book-a/index.html">Linux Practice Exercises </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-01-week1/unit-2/book-a/index.html">Home Network </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-02-week2/unit-1/book-a/index.html">Scripting Exercises </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-02-week2/unit-2/book-1-vagrant/index.html">Vagrant and Virtualisation </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-03-week3/unit-1/book-a/index.html">CPU </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-03-week3/unit-2/book-1-packet-sniffing/index.html">Packet Sniffing using TShark </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-04-week4/unit-1/book-a/index.html">NoBases </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-04-week4/unit-2/book-1-IP-Networking/index.html">IP Networking </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-05-week5/unit-1/book-a/index.html">Boolean </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-05-week5/unit-2/book-a/index.html">The Headless RPi </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-06-week6/unit-1/book-a/index.html">Logic </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-06-week6/unit-2/book-a/index.html">Presence Detector 1 </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-06-week6/unit-2/book-b/index.html">BLE </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-07-week7/unit-1/book-a/index.html">Shell Scripting </a>
      
    
      
        <a class="item"
           href="http://wit-hdip-comp-sci-2018.github.io/computer-systems//topic-07-week7/unit-2/book-a/index.html">TCP-Sockets </a>
      
    
  </div>
  <div class="pusher" tabindex="-1">
    <div class="ui basic segment">
      <br>
      
        <div class="ui tab segment lab" data-tab="TCP-Sockets">
          <h1>TCP Sockets</h1>
<p>This lab explores Transport layer protocols.</p>
<h2>Objectives</h2>
<ul>
<li>Set up a TCP/IP socket client/server in your virtual network.</li>
<li>Use TShark to filter and record TCP traffick.</li>
<li>Analyse recorded TCP data and observe TCP protocol features.</li>
<li>Modify TCP client to connect to remote TCP socket server.</li>
<li>Observe and understand TCP packets.</li>
</ul>
<h2>Introduction</h2>
<p>In this lab you will download a TCP client and server program written in Java and Python by cloning a repository. The Java and Python code may be incomplete or contain bugs, but your knowledge of sockets and Java should enable you to produce a working version.
To test your client/server programs, you will compile the code and place it in the shared vagrant directory of the virtual network from the last lab. This will make them available in each of the virtual machines in the <em>/vagrant</em> directory.</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="01">
          <h2>Java sockets program</h2>
<p>Clone the following repo into a suitable location on your machine:</p>
<p><a href="https://github.com/wit-computing/hdip-socket-to-me.git">https://github.com/wit-computing/hdip-socket-to-me.git</a></p>
<p>The cloned repo is an IntelliJ project. Start IntelliJ and do <em>File-&gt;Open</em> and select the repo directory.</p>
<p>The sockets project contains two Java programs, a simple Sockets Server and Client. Take a look at Server.java in the editor. Although you have covered all of the Java concepts shown in this program (such as threads...) you should be able to inspect the code and have a reasonable idea how the program will behave when executed. Answer the following:
+ What port number will the server bind to?
+ What statement actually binds the program to the port?
+ Notice that there is plenty of code for handling IOException. From a networking perspective, Why do you think this is required?</p>
<p>You will now deploy the sockets Server to <em>PC0</em>. One way to do this is to copy the compiled byte code (i.e. Server.class) to the shared vagrant directory on your laptop. In IntelliJ, select the <em>socket-echo</em> project anb then select <em>Build-&gt;Build Project</em>. This will make sure the project is compiled to the <em>out</em> directory.<br><img src="./img/out.png" alt="IntelliJ out directory"><br>Copy the <em>Server.class</em> and <em>Client.class</em> files to your shared Vagrant directory. Now start the Vagrant virtual environment as usual by opening a terminal window in you Vagrant directory and entering <code>vagrant up</code>.<br>As before, open a SSH session with PC0.Change directory to the <em>/vagrant</em> folder and run the Server from the commandline:
 <img src="./img/server.png" alt="Running Server"><br>Now, open a session on pc1 and run the client. Something&#39;s wrong! Client.java compiles but it does not connect to the server. You should see something similar to the following.<br><img src="./img/client1.png" alt="Client: not connected "><br>You will need to figure out why the client failed. Have a look at the code and keep in mind that, in order for the client to connect to a socket, it needs the correct IP address and port that the Server is listening on. Fix the issue and run the Client program again. If you fix it, you should see the following:<br><img src="./img/client2.png" alt="Client: connected"><br>Start to enter some text in the Client terminal and hit <em>Return/Enter</em>. You should see the text echoed back to you from the server on pc0. This is using TCP/IP protocol to do this. Lets have a look at how this looks &quot;on the wire&quot; using TShark.  </p>
<h3>Optional Challenge</h3>
<p>In your programming module, you created a &quot;tech support&quot; program that generated automated responses based on requests. If you have time, why don&#39;t you try to reuse the tech support code to make the Server behave the same way (and not just echo every request).</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="02">
          <h1>TCP/IP</h1>
<p>So we have a client/server connection over TCP/IP sockets. Now lets start recording network traffic and examin the TCP/IP interaction:</p>
<p>Disconnect your client program running on pc1 by entering ctrl+c in the SSH session.</p>
<p>Start another SSH session with pc0 and start TShark recording on interface eth1 and filter on port 10500(i.e. the port our server program is using):</p>
<pre><code class="lang-bash">~$ tshark -w /vagrant/pc0-eth0-traffic3.pcap -i eth1 -f &quot;tcp port 10500&quot;</code></pre>
<p>Now connect to the server using the client program again and send a few lines of text:
 <img src="./img/client4.png" alt="TCP Client sending text"></p>
<p>You should have some network traffic data recorded in <em>/vagrant/pc0-eth0-traffic3.pcap</em>. As before, lets open the file and have a look using <code>tshark -r pc0-eth0-traffic3.pcap</code>. You should see similar output to the following:
<img src="./img/tcp1.png" alt="TCP data"></p>
<p>Have a look at the data and answer the following question:<br>+ Can you locate the TCP 3-way handshake. How many times does it happen.
 + What&#39;s the port number of the client? Why is it this number?
 + Disonnect and connect the client again and have a look at the client port number and 3-way handshake. What happens?
+ As you see, the TCP connection is negotiated at each connection, thereafter transmission can commence.
+ Have a closed look at the data that&#39;s transmitted. Pick a &quot;push&quot; frame(one with [PSH,ACK] flag it&#39;ll contain data) and inspect the encapsulation:  </p>
<pre><code class="lang-bash">$ tshark -r pc0-eth0-traffic3.pcap -V -Y &quot;frame.number==12&quot;
Frame 12: 80 bytes on wire (640 bits), 80 bytes captured (640 bits) on interface 0
    Interface id: 0 (eth1)
    Encapsulation type: Ethernet (1)
. . . . . .
Transmission Control Protocol, Src Port: 10500, Dst Port: 37075, Seq: 11, Ack: 25, Len: 14
    Source Port: 10500
    Destination Port: 37075
    [Stream index: 0]
    [TCP Segment Len: 14]
    Sequence number: 11    (relative sequence number)
    [Next sequence number: 25    (relative sequence number)]
    Acknowledgment number: 25    (relative ack number)
    Header Length: 32 bytes
    Flags: 0x018 (PSH, ACK)
        000. .... .... = Reserved: Not set
        ...0 .... .... = Nonce: Not set
        .... 0... .... = Congestion Window Reduced (CWR): Not set
        .... .0.. .... = ECN-Echo: Not set
        .... ..0. .... = Urgent: Not set
        .... ...1 .... = Acknowledgment: Set
        .... .... 1... = Push: Set
        .... .... .0.. = Reset: Not set
        .... .... ..0. = Syn: Not set
        .... .... ...0 = Fin: Not set
        [TCP Flags: ·······AP···]
. . . . . . .
Data (14 bytes)

0000  72 65 61 6c 6c 79 20 72 65 61 6c 6c 79 0a         really really.
    Data: 7265616c6c79207265616c6c790a
    [Length: 14]</code></pre>
<ul>
<li>Have a look at the TCP and Data section of the Frame. Notice how the Flags past of the datagram indicates what type of transmission it is.<ul>
<li>How can the same datagram act as an Acknowledgement and a Push?</li>
<li>How does the raw data translate into the text sent? Id this data &quot;safe&quot; during Transmission?</li>
</ul>
</li>
</ul>

        </div>
      
        <div class="ui tab segment lab" data-tab="03">
          <h1>TCP/IP Packets</h1>
<p>The objective in this section is to demonstrate:</p>
<ul>
<li>TCP is stream-orientated</li>
<li>Packetisation of streamed data.</li>
</ul>
<p>To do this you will modify the TCP client connect to a different TCP server in the cloud(or create it on your Pi if you have it already).</p>
<h2>Smart Environment Scenario:</h2>
<p>Let’s assume we have a remote sensor device as part of a smart environment infrastructure for monitoring temperature at several locations.
The remote sensor device (the TCP server) waits for a request from a data aggrigator(the TCP client) for data. It behaves as follows:
+ On receiving a message from the data aggrigator, the remote device sends <em>n</em> sensor values, in this case the temperature.
+ The server closes the connection after sending the <em>n</em> messages. 
+ The aggrigator(client) does not know the value of <em>n</em> before the request is made.
+ The request from the aggrigator is a value indicating the time period between transmitting each sensor reading. The value, in seconds, is given as a command line argument to the client.
+ If no time is specified, the server will try to send all <em>n</em> values at the same time. </p>
<h4>Starting the Server</h4>
<p>On <em>PC0</em>, change directory to the synced /vagrant folder and open the <code>server.py</code> using nano.</p>
<pre><code class="lang-bash">vagrant@pc0:~$ cd /vagrant
vagrant@pc0:/vagrant$ ls
Client.class      Server.class  client.py        pc0-eth1-traffic1.pcap
Client.java       Server.java   lots-of-data.txt        pc0-eth1-traffic2.pcap
HelloWorld.class  Vagrantfile   pc0-eth0-traffic2.pcap  pc0eth1traffic1.pcap
HelloWorld.java   bootstrap.sh  pc0-eth0-traffic3.pcap  server.py
vagrant@pc0:/vagrant$ nano server-simple.py</code></pre>
<p>Update the server code so that your server listens on the correct port (i.e. 50200).
Now run the server by typing <code>python simple-server.py</code> at the command prompt. All going well, you should see a message &quot;Server up and running...&quot;</p>
<pre><code class="lang-bash">vagrant@pc0:/vagrant$ python server-simple.py
Server up and running...</code></pre>
<h4>Running the Client</h4>
<p>Open a SSH session with <em>pc1</em> and change directory to the syched folder. Using nano, have open <em>client.py</em> and change the IP address and port number to connect to the server on <em>pc0</em>. Start the client program by typing <code>python client.py</code> at the command prompt. The client program takes one arguement which is time period between sending each of the <em>n</em> sensor values back to the client. </p>
<p>On <em>pc1</em>, run the client with 0 time delay by typing <code>python client.py 0</code> at the command prompt. You should see something similar to the following:<br><img src="./img/pc0-tcp1.png" alt="pc0 - server.py"><img src="./img/pc1-tcp1.png" alt="pc1-client.py-0 delay">  </p>
<p>Now, on <em>pc1</em>, run the client with 0.01 time delay(1/100th of a second) by typing <code>python client.py 0.01</code> at the command prompt. You should see something similar to the following:<br><img src="./img/pc0-tcp1.png" alt="pc0 - server.py"><img src="./img/pc1-tcp2.png" alt="pc1-client.py-0.01 delay"><br>Notice the difference in the output of client.py program for 0 delay and 0.01. Taking into account of what was discussed in class:
+ what are the possible reasons for the differing output?
+ what do you think is happening with the TCP packets.</p>
<p>To try and make sense of what&#39;s going on at a network level, lets repeat the above exercise except this time we&#39;ll capture and analyse some tcp network data on the client side.</p>
<p>Open another terminal window and connect to <em>pc1</em> using SSH(you should have two ssh sessions with <em>pc1</em> open now). Run TShark to filter on port 50200 with a payload greater than 0. We&#39;ll listen on interface <code>eth0</code> and write the data to a file. We&#39;ll capture everything so no filters.</p>
<pre><code class="lang-bash">tshark -i eth1 -w pc0-eth1-tcp-sensor.pcap</code></pre>
<p>Now run the <code>python client.py 0</code> to capture the network traffic for 0 delay.</p>
<pre><code class="lang-bash">vagrant@pc1:/vagrant$ python client.py 0
Sent:     0
Received: 25,21/06/2018 00:00:00

Received: 25,21/06/2018 00:01:00
12,21/06/2018 00:02:00
16,21/06/2018 00:03:00
...</code></pre>
<p>Stop tshark by entering <code>ctrl-c</code> in the network capure session and restart it but this time write the results to <code>pc0-eth1-tcp-delay.pcap</code></p>
<pre><code class="lang-bash">tshark -i eth1 -w pc0-eth1-tcp-0-delay.pcap -f &quot;src port 50200&quot; -T fields -e frame.number -e frame.len -e ip.len -e tcp.len  -E header=y</code></pre>
<p>Now run the <code>python client.py 0.01</code> to capture the network traffic for 0 delay.</p>
<pre><code class="lang-@bash">vagrant@pc1:/vagrant$ python client.py 0.01
Sent:     0.01
Received: 25,21/06/2018 00:00:00

Received: 25,21/06/2018 00:01:00

Received: 12,21/06/2018 00:02:00
...</code></pre>
<p>Finally, repeat the proceedure for writing all the data in one go.</p>
<pre><code class="lang-bash">vagrant@pc1:/vagrant$ python client.py
Sent:     
Received: 25,21/06/2018 00:00:00
25,21/06/2018 00:01:00
12,21/06/2018 00:02:00
16,21/06/2018 00:03:00
...</code></pre>
<p>Lets examine the captured data. We can use the -Y (Yank filter) to query specific aspects of the data and filter based on field names. As all the data is in the same file, we need a way to query the specifics for each of the 3 scenarios. One way to do this for the first experiment is to look for the frame that contains each request. 
For the experiments, you know that the payload(data) of the tcp request from the client to tcp port 50200 was &quot;0&quot;, &quot;0.01&quot; and null(nothing) in that order so lets look for that:</p>
<pre><code class="lang-bash">vagrant@pc1:~$ tshark -r pc0-eth1-tcp-sensor.pcap  -o data.show_as_text:TRUE -T fields -e frame.number -e data.text  -E header=y -Y &quot;tcp.len&gt;0 &amp;&amp; tcp.dstport==50200&quot;
frame.number    data.text
7                0

53                0.01

460</code></pre>
<p>So, from the above data you can identify the frame number of each of the requests. Thus the tcp reponses for each request lie between each frame. So for the reuest for 0 delay the responses will have a frame numbet in the range 8-52. So lets look at the the tcp packets with a source port of 129.168.5.2, port 50200 in that range:</p>
<pre><code class="lang-bash">frame.number    ip.src    tcp.len
8    192.168.5.2    0
9    192.168.5.2    24
11    192.168.5.2    336
12    192.168.5.2    1448
15    192.168.5.2    400
17    192.168.5.2    144
19    192.168.5.2    360
21    192.168.5.2    120
23    192.168.5.2    168
25    192.168.5.2    312
27    192.168.5.2    96
29    192.168.5.2    192
31    192.168.5.2    312
33    192.168.5.2    96
35    192.168.5.2    72
37    192.168.5.2    72
39    192.168.5.2    96
41    192.168.5.2    192
43    192.168.5.2    288
45    192.168.5.2    48
47    192.168.5.2    0
49    192.168.5.2    0
51    192.168.5.2    0</code></pre>
<p>From the above, I can see that 23 tcp packets were required to recieve the data at the clients (19 to transfer the data). This will be different every time you run it. </p>
<p>Lets run the same query for the 2nd experiment where delay was set to 0.01 seconds for each transmission.</p>
<pre><code class="lang-bash">vagrant@pc1:~$ tshark -r pc0-eth1-tcp-sensor.pcap  -o data.show_as_text:TRUE -T fields -e frame.number -e ip.src -e tcp.len    -E header=y -Y &quot;tcp.srcport==50200 &amp;&amp; frame.number&gt;53 &amp;&amp; frame.number&lt;460&quot;
frame.number    ip.src    tcp.len
54    192.168.5.2    0
55    192.168.5.2    24
57    192.168.5.2    24
59    192.168.5.2    24
...
446    192.168.5.2    24
448    192.168.5.2    24
450    192.168.5.2    24
452    192.168.5.2    24
454    192.168.5.2    0
456    192.168.5.2    0
458    192.168.5.2    0</code></pre>
<p>You can see that far more tcp packets are used to trasport the data to the client. If we include the tcp.data field to have a look at the payload, you will see there&#39;s a tcp packet for each sensor value. This is due to the delay and the way the server program works.</p>
<p>Finally, lets run a query to look at the big bang approach to send all the data at once.</p>
<pre><code class="lang-bash">vagrant@pc1:~$ tshark -r pc0-eth1-tcp-sensor.pcap -T fields -e frame.number -e ip.src -e tcp.len    -E header=y -Y &quot;tcp.srcport==50200 &amp;&amp; frame.number&gt;460&quot;
frame.number    ip.src    tcp.len
461    192.168.5.2    0
462    192.168.5.2    14480
464    192.168.5.2    9519
466    192.168.5.2    0
468    192.168.5.2    0
vagrant@pc1:~$</code></pre>
<p>You can see here that the data is now transferred in 5 tcp packets. Notice that the data is split into 2 packets for transission in this case.
+ Why do you think this happens? 
+ Where does the split happen, in the server program or in the tcp stack? </p>
<p>Lets change the query to have a look at what the payload looks like for a data carrying frame, number 462 (you&#39;ll have to scroll up to have a look at it:</p>
<pre><code class="lang-bash">vagrant@pc1:~$ tshark -r pc0-eth1-tcp-sensor.pcap  -o data.show_as_text:TRUE -T fields -e frame.number -e ip.src -e tcp.len -e data.text    -E header=y -Y &quot;frame.number==464&quot;
frame.number    ip.src        tcp.len    data.text
464                192.168.5.2    9519    6/2018 10:03:00
18,21/06/2018 10:04:00
19,21/06/2018 10:05:00
25,21/06/2018 10:06:00
...</code></pre>
<p>You can see that the payload has been broken up into 2 packets. The data in the above example begins with a partial sensor reading (the rest of it is in frame 462) followed by other readings. This data will be reassembled in the TCP/IP stack before being delivered to the application. </p>

        </div>
      
    </div>
  </div>
</div>

<script>
  $(document).on('keydown', function(e) {
  e = e || window.event;
  var nextTab;
  switch (e.which || e.keyCode) {
    case 37: // left
      nextTab = $('.tab-menu a[data-tab].active').prev('a[data-tab]');
      if (!nextTab.length) nextTab = $('.tab-menu a[data-tab]').last();
      nextTab.click();
      $('.pusher').focus();
      break;

    case 39: // right
      nextTab = $('.tab-menu a[data-tab].active').next('a[data-tab]');
      if (!nextTab.length) nextTab = $('.tab-menu a[data-tab]').first();
      nextTab.click();
      $('.pusher').focus();
      break;
  }
});

  $(document).ready(function() {
  $('img').addClass('ui image');

  $('.ui.embed').embed();

  const $images = $('.lab img');
  jQuery.each($images, function(i) {
    if ($images[i].alt.length > 0) {
      const divImg = $(document.createElement('div')).addClass(
        'ui basic segment',
      );
      $($images[i]).wrap(divImg);
      const divLabel = $(document.createElement('div')).addClass(
        'ui blue ribbon label',
      );
      divLabel.append($images[i].alt);
      $(divLabel).insertBefore($images[i]);
    }
  });

  $('.ui.menu .item').tab({
    history: true,
    historyType: 'hash',
  });

  $('.popup').popup();

  $('.ui.sidebar')
    .sidebar({ context: $('.pushable') })
    .sidebar('setting', 'transition', 'slide out')
    .sidebar('attach events', '#toc');
});

</script>
</body>
</html>